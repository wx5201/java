## 设计思想
### 面向过程
　　"面向过程"(Procedure Oriented)是一种以过程为中心的编程思想。"面向过程"也可称之为"面向记录"编程思想，他们不支持丰富的"面向对象"特性(比如继承、多态)，并且它们不允许混合持久化状态和域逻辑。

　　面向过程编程采取的是时间换空间的策略，因为在早期计算机配置低，内存小，如何节省内存则成了首要任务，哪怕是运行的时间更长。随着硬件技术的发展，硬件不再成为瓶颈，相反更好的模拟现实世界、系统的可维护性等问题凸显出来，于是面向对象设计应运而生。当下：应用在PC机上的一般应用系统，由于不太需要考虑硬件的限制，而系统的可维护性等方面却要求很高，一般采用面向对象方式；而在内存限制有所要求的嵌入式系统，则大多采用面向过程方式进行设计编程。

　　面向过程是分析解决问题的步骤，然后用函数把这些步骤一步一步的实现，然后在使用的时候一一调用则可。面向对象是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。
### 面向对象
　　面向对象开发方法（ObjectOriented，OO）又称：快速原型法。
　　面向对象是当今软件开发方法的主流方法之一，他是把数据以及对数据的操作放在一起，作为一个相互依存的整体，就是我们所说的对象。对同类对象抽象出其共性，就是类，类中的大多数数据，只能被本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定，例如，站在抽象的角度，人具有身高，体重，年龄，血型等一些特征，人会劳动，会行走，会吃饭等这些方法，人仅仅是一个抽象的概念，它是不存在的实体，但是所有具备人这个群体的属性与方法的对象都叫做人，这对象人是实际存在的实体，每个人都是人这个群体的一个对象。
　　客观世界是由各种各样的对象组成的，每种对象都有各自的内部状态和运动规律，不同对象之间的相互作用和联系就构成了各种不同的系统。
　　在设计和实现一个客观系统时，在满足需求的条件下，把系统设计成一些不可变的（相对固定）部分组成的最小集合（最好的设计）。这些不可变的部分就是所谓的对象
英文及缩写：

　　面向过程：procedure oriented programming POP

　　面向对象：object oriented programming OOP
　　下面举一例说明面向过程和面向对象编程。

　　首先使用面向过程：

1、开始游戏，

2、黑子先走，

3、绘制画面，

4、判断输赢，

5、轮到白子，

6、绘制画面，

7、判断输赢，

8、返回步骤2，

9、输出最后结果。

　　把上面每个步骤用分别的函数来实现，问题就解决了。

　　面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为：

　　1、黑白双方，这两方的行为是一模一样的，

　　2、棋盘系统，负责绘制画面，

　　3、规则系统，负责判定诸如犯规、输赢等。

　　第一类对象(玩家对象)负责接受用户输入，并告知第二类对象(棋盘对象)棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象(规则系统)来对棋局进行判定。

　　面向对象保证了功能的统一型，从而为扩展打下基础。现在要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。由此可以看出面向对象更易于扩展。

 下面简单介绍面向对象三大特征：

　　封装：

　　封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现，外界只能通过接口使用该对象，而不能通过任何形式修改对象内部实现，正是由于封装机制，程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。

　　继承：

　　继承来源于现实世界，一个最简单的例子就是孩子会具有父母的一些特征，即每个孩子都会继承父亲或者母亲的某些特征，当然这只是最基本的继承关系，现实世界中还存在着更复杂的继承，面向对象之所以使用继承机制主要是用于实现代码的复用多个类所公用的代码部分可以只在一个类中提供，而其他类只需要继承即可。

　　多态：

　　多态与继承纤细紧密，是面向对象编程中另一个突出的特征，所谓的多态是指在继承体系中，所有派生类都从基类继承接口，但由于每个派生类都是独立的实体，因此在接收同一消息的时候，可能会生成不同的响应。多态的作用作为隐藏代码实现细节，使得代码能够模块化;扩展代码模块，实现接口重用。简单来说：一种行为产生多种效果。

　　总的来说：封装可以隐藏实现细节同时包含私有成员，使得代码模块化并增加安全指数；基础可以扩展已存在的模块，目的是为了代码重用；多态则是为了保证：类在继承和派生的时候，保证家谱中任何类的实例被正确调用，实现了接口重用。

　　多态实现：

　　实现多态，有二种方式，覆盖，重载。

　　覆盖，是指子类重新定义父类的虚函数的做法。

　　重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

　　其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关。

 

　　扯到覆盖和重载了，那就说说函数重载、覆盖、隐藏的基本定义吧。

　　函数重载：是指允许存在多个同名函数，这些函数的参数列表不同，或许是参数个数不同，或许是参数类型不同，或许是两者都不同。重要一点：函数重载是发生在同一个类中。调用时，根据参数类型的不同进行调用，同时编译器在编译期间就确定了要调用的函数。（函数的重载与多态无关）。

　　函数覆盖：函数覆盖也被称为函数重写（override），是子类重新定义基类虚函数的方法。

　　构成函数覆盖的条件：

（1）基类的函数必须是虚函数（virtual进行声明）

（2）发生覆盖的两个函数必须分别位于派生类和基类中

（3）函数名称和参数列表必须完全相同

　　由于c++，c#多态性是通过虚函数来实现的，所以函数覆盖总是和多态联系在一起，并且是程序在运行时才确定要调用的函数，因此也成为动态绑定或者后期绑定。

 

　　函数隐藏：指子类中具有和基类同名的函数，但是并不考虑参数列表是否相同，从而在子类中隐藏了基类的同名函数。有以下两种情况：

　　（1）子类函数和基类函数完全相同，只是基类的函数没有使用virtual关键字，此时基类的函数将被隐藏。

　　（2）子类函数和基类函数名字相同，但是参数列表不同，在这种情况下，无论基类的函数是否声明为virtual，基类的函数都将被隐藏。

 

　　一个小例子：

``` java
using System;
class A
{
    public void F() { Console.WriteLine("A.F"); }
    public virtual void G() { Console.WriteLine("A.G"); }
}

class B : A
{
    new public void F() { Console.WriteLine("B.F"); }
    public override void G() { Console.WriteLine("B.G"); }
}

class Test
{
    static void Main()
    {
        B b = new B();
        A a = b;

        a.F();
        b.F();
        a.G();
        b.G();
        Console.ReadLine();
    }
}
```
　　上面实例运行结果为：A.F B.F B.G B.G。由此可以得出：对于非虚方法来说，无论是被其所在的类的实例调用，还是被其所派生的类的实例调用，方法的执行方式不变。但对于虚方法来说，它的执行方式可以被派生类改变，并且是通过重载来实现的。